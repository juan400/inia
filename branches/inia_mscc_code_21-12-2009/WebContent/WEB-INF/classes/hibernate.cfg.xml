<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
          "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
	<session-factory>
		<!-- Database connection settings -->
		<property name="connection.driver_class">com.mysql.jdbc.Driver</property>
		<property name="connection.url">jdbc:mysql://localhost:3306/inia_mscc_db</property>
		<property name="connection.username">inia_db</property>
		<property name="connection.password">inia</property>
				<!-- JDBC connection pool (use the built-in) -->
		<property name="connection.pool_size">1</property>

		<!-- SQL dialect -->
		<property name="dialect">org.hibernate.dialect.MySQL5InnoDBDialect</property>
		<!-- this will show us all sql statements -->
		<property name="show_sql">true</property>
		
        <!-- Drop and re-create the database schema on startup -->
		<!--<property name="hbm2ddl.auto">create</property>-->

		<!--
			thread is the short name for
			org.hibernate.context.ThreadLocalSessionContext and let Hibernate
			bind the session automatically to the thread
			The advantage of the built-in support should become clear as soon 
			as you write non-trivial applications: you can separate the transaction 
			demarcation code from your data access code. The "current session" refers 
			to a Hibernate Session bound by Hibernate behind the scenes, to the transaction scope. 
			A Session is opened when getCurrentSession() is called for the first time and closed when 
			the transaction ends. It is also flushed automatically before the transaction commits. 
			You can call getCurrentSession() as often and anywhere you want as long as the transaction runs. 
			To enable this strategy in your Hibernate configuration:

			set hibernate.transaction.manager_lookup_class to a lookup strategy for your JEE container
			set hibernate.transaction.factory_class to org.hibernate.transaction.JTATransactionFactory
			See the Hibernate reference documentation for more configuration details.

			This does not mean that all Hibernate Sessions are closed when a transaction is committed! 
			Only the Session that you obtained with sf.getCurrentSession() is flushed and closed automatically. 
			If you decide to use sf.openSession() and manage the Session yourself, you have to flush() and 
			close() it. So a less convenient alternative, without any "current" Session.
		-->
		<property name="transaction.factory_class">org.hibernate.transaction.JDBCTransactionFactory</property>
		<property name="current_session_context_class">thread</property>
		
		<!-- mapping files -->
		<mapping resource="Usuario.hbm.xml" />
		
		<!--
		<mapping resource="Author.hbm.xml" />
		<mapping resource="AdaptedFactor.hbm.xml" />
		<mapping resource="AdaptedMethod.hbm.xml" />
		<mapping resource="AdaptedMetric.hbm.xml" />
		<mapping resource="Dimension.hbm.xml" />
		<mapping resource="Factor.hbm.xml" />
		<mapping resource="Goal.hbm.xml" />
		<mapping resource="Measure.hbm.xml" />
		<mapping resource="MeasureDW.hbm.xml" />
		<mapping resource="Method.hbm.xml" />
		<mapping resource="Metric.hbm.xml" />
		<mapping resource="ObjectType.hbm.xml" />
		<mapping resource="Parameter.hbm.xml" />
		<mapping resource="ParameterValue.hbm.xml" />
		<mapping resource="Question.hbm.xml" />
		<mapping resource="User.hbm.xml" />
	--></session-factory>
</hibernate-configuration>
