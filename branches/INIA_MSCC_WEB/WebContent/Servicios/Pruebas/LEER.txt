import numpy #Provee objetos arrays que no son nativos de python
from mx import DateTime

##Estas son las arrays que se definen en el xml y caracterizan el clima de ua region **********************
#order: rows: max_C, min_C, solar_rad, cols: mean: a, b, c, d, stdev: a, b, c, d
param_dict= {'dry':  [[-14.974737211233927, 0.015636886230500097, 1.574329296449279, 11.532013519495585, 1.4200818794930099, 0.019835241996656455, 0.36178643519394749, 4.6960945435392265],
					  [-12.607026868237501, 0.01644817504524268, 1.3389681268941718, 2.0983606157408747, 1.446519606509828, 0.015670217929789051, 1.3967338855632128, 4.5503280665089969],
					  [229.58347668767991, 0.016033219592976149, -1.1484582365319118, 329.15476806896186, 41.50980793045629, 0.014472308834135071, -0.67016098373625821, 84.510507285933485]], 
			 'wet': [[-12.925455392811854, 0.017311475775113421, 1.2019800640953939, 12.373124838415173, 1.1406368970931773, 0.021733921890600392, -0.00466885771765324, 4.5028413295737195],
					  [-12.056801821532833, 0.017290180610238164, 1.1635140486223283, 4.3342738004304442, 1.5765905236974651, 0.015795774310735387, 1.5040647292366149, 4.0380182600585091],
					  [140.9127971622481, 0.017868978637799508, -1.5584047076567853, 215.80610127472397, 50.624280723563047, 0.015326278863157008, -0.97734210161354629, 84.543269465709486]]}

#[P000,P010,P100,P110] from out precip data, i.e.: [drydrydry,drywetdry,wetdrydry,wetwetdry]
prob_=[0.62259353432618958, 0.44121447028423771, 0.67097608274078857, 0.48002219755826858]

#**********************************************************************************************************

def C_F(tc):
	tf=9*float(tc)/5+32
	return tf

def precip(mean):    #our data has an overall mean of 6.217768
	k=numpy.random.random()
	ppt=-mean*numpy.log(1-k)
	return ppt

def sin_fit(state, day):
	#models non precip variables based on best fit sin curves. Need to add stochasticity and constant matrix effects- but this gives mean
	c=param_dict[state]
	p=[]   #order: max_C, min_C, solar_rad: [mean, Stdev]
	p.append([c[0][0]*numpy.sin(c[0][1]*day+c[0][2])+c[0][3],c[0][4]*numpy.sin(c[0][5]*day+c[0][6])+c[0][7]])
	p.append([c[1][0]*numpy.sin(c[1][1]*day+c[1][2])+c[1][3],c[1][4]*numpy.sin(c[1][5]*day+c[1][6])+c[1][7]])
	p.append([c[2][0]*numpy.sin(c[2][1]*day+c[2][2])+c[2][3],c[2][4]*numpy.sin(c[2][5]*day+c[2][6])+c[2][7]])
	return p
	
def zmodel(day,state,tablerow,ppt2,RefDay):
	[[maxcm,maxcs],[mincm,mincs],[sm,ss]]=sin_fit(state,day)  #generates the seasonally and 
	#moisture dependent mean and stdev for each variable on the given day.
	e=numpy.random.normal(0,1,3)  #generates 3 normally distributed random numbers, mean=-, stdev=1
	if day>0:
		max_c=maxcm+maxcs*e[0]#maxc
		min_c=mincm+mincs*e[1]#minc
		sol_rad=sm+ss*e[2]#solrad
	else:	max_c=maxcm;min_c=mincm;sol_rad=sm
	if abs(max_c)>1000000: max_c=1000000
	if abs(min_c)>1000000: min_c=1000000
	if abs(sol_rad)>1000000: sol_rad=1000000
	return [RefDay+day,C_F(max_c),max_c, C_F(min_c),min_c,(min_c+max_c)/2,ppt2,sol_rad]


def ppt_occ(prob,adj=[0,0,0,365]):
	#adj=[adj1,adj2,adjs,adje]
	#adjs=start adjusting probabilities by adj1 until adje, then continue adjusting by adj2
	#prob=[P000,P010,P100,P110]
	#if trmt=='control': adj=[0,0,0,365]

	p_adj1=[i+adj[0] for i in prob]
	p_adj2=[i+adj[1] for i in prob]
	if adj[2]==0: p=p_adj1
	else:p=p_adj2
	rand=numpy.random.random(2)
	ppt=[]
	if rand[0]<(sum(p))/4:		 		ppt.append(0)
	else: 						ppt.append(1)

	if ppt[0]==1:
		if rand[1]<(p[1]+p[3])/2: 		ppt.append(0)
		else: 					ppt.append(1)
	else:
		if rand[1]<(p[0]+p[2])/2: 		ppt.append(0)
		else: 					ppt.append(1)

	rand=numpy.random.random(365)
	for day in range(2,365):
		if day==adj[2]:		p=p_adj1
		if day==adj[3]:		p=p_adj2
		if ppt[(day-2)]==1:
			if ppt[(day-1)]==1:
				if rand[day]<p[3]: 	ppt.append(0)
				else: 			ppt.append(1)
			else:
				if rand[day]<p[2]:	ppt.append(0)
				else: 			ppt.append(1)
		else:
			if ppt[(day-1)]==1:
				if rand[day]<p[1]:	ppt.append(0)
				else:			ppt.append(1)
			else:
				if rand[day]<p[0]:	ppt.append(0)
				else:			ppt.append(1)
	return ppt

def Sim_wea(yearbounds=[2007,2009],prob=prob_,meanppt=6.217768,intensity=1.,adj=[0,0,0,365]):
	#Simulates ppt occurances. 
	#yearbounds=years for which to generate climate
	#intensity=changes the mean precipitation intensity by factor
	#adj=adjusts the probability of precipitation occurence during a specif period of time (see ppt_occ) 
	table=[[DateTime.Date(int(0),1,1),0,0,0,0,0,0,0]]
	i=0
	meanppt=meanppt*intensity
	for year in range(yearbounds[0],yearbounds[1]):
		ppt=ppt_occ(prob,adj=[0,0,0,365])
		RefDay=DateTime.Date(year,1,1)
		for day in range(0,365):		#might mis leap year days, but will miss in Dec and not matter
			if ppt[day]==1:			state='wet';	ppt2=precip(meanppt)
			elif ppt[day]==0:		state='dry'; 	ppt2=0
			table.append(zmodel(day,state,table[i],ppt2,RefDay))
			i+=1
	#import pickle

	#    f=open('Wather_sim_pickle.txt', 'w');pickle.dump(table, f);f.close()
	return table